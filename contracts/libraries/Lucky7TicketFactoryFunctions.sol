// /**
//   * @author Matias Barrios
//   * @version 1.0
//   */

// /** @title Lucky7TicketFactor. 
//   * This contract contains all the functions to generate tickets and Lucky7Numbers.
//   * Inherits from Lucky7Admin and usingOraclize to do the oraclize querys. 
// */

// pragma solidity ^0.4.20;

// import "../SafeMath.sol";
// import {usingOraclize} from "../usingOraclize.sol";

// library Lucky7TicketFactoryFunctions{
//     /** @dev SafeMath library is used for the _checkForLucky7Ticket of this contract. 
//       */
//     using SafeMath for uint256;
//     uint oraclizeGasLimit;
    
//     /**@dev The events are used mainly for testing purposes
//       */
//     event NewOraclizeQuery(string description);
//     event NewMuReceived(string muParameter);
//     event NewIReceived(string iParameter);
//     event NewTicketReceived(string newTicket);
//     event NewWolframQuery(string description);
//     event NewLucky7Ticket(uint ticketID);
//     event NewLucky7Number(uint value);

//     /** @param settingLucky7Numbers is a circuit breaker to stop users of buying tickets while the game is getting setted
//       *i.e. when a new game is started, previous winners are erased, the Lucky7Numbers are getting setted and prizes are delivered.
//       */
//     bool public settingLucky7Numbers = true;
    
//     /** @dev Function to toggle the settingLucky7Numbers to stop users to buy tickets. 
//       */
//     function toggleLucky7Setting() public {
//         settingLucky7Numbers = !settingLucky7Numbers;
//     }
    
//     /** @dev _askForMuParameter is a function to ask for a new mu parameter through an oraclize query.
//       * @param _ticketOwner is the address of the user which is calling this function through a generation of new parameters or by buying a new random ticket.
//       * First, it emit an event to register the query. Then it do the query and save the bytes32 value generated to the muID.
//       * Finally it associate this muID with the _ticketOwner through the muParameterID mapping, so the oraclize's callback function know it is a mu petition and it belongs to the _ticketOwner user.
//       */
//     function _askForMuParameter(address _ticketOwner) public{
//         emit NewOraclizeQuery("Asking for a new mu parameter...");
//         bytes32 muID = usingOraclize.oraclize_query("WolframAlpha","4 random number",oraclizeGasLimit);
//         muParameterID[muID] = _ticketOwner;
//     }

//     /** @dev _askForIParameter is a function to ask for a new I parameter through an oraclize query.
//       * @param _ticketOwner is the address of the user which is calling this function through a generation of new parameters or by buying a new random ticket.
//       * First, it emit an event to register the query. Then it do the query and save the bytes32 value generated to the iID.
//       * Finally it associate this iID with the _ticketOwner through the iParameterID mapping, so the oraclize's callback function know it is a i petition and it belongs to the _ticketOwner user.
//       */
//     function _askForIParameter(address _ticketOwner) public{
//         emit NewOraclizeQuery("Asking for a new i parameter...");
//         bytes32 iID = oraclize_query("WolframAlpha","4 random number",oraclizeGasLimit);
//         iParameterID[iID] = _ticketOwner;
//     }
    
//     /** @dev _askForTicket is a function to ask for a new ticket through an oraclize query.
//       * @param _ticketOwner is the address of the user which is calling this function through by buying a new random ticket or buying the ticket generated by it parameters.
//       * First, it emit an event to register the query. Then it do the query and save the bytes32 value generated to the userTicketID.
//       * Finally it associate this userTicketID with the _ticketOwner through the newTicketID mapping, so the oraclize's callback function know it 
//       * is a ticket petition and it belongs to the _ticketOwner user. Inside the oraclize_query function it calls the _setTicketQuery function, so it generate the query 
//       * depending on the UserParametersValue struct of the _ticketOwner user.
//       */
//     function _askForTicket(address _ticketOwner) public{
//         emit NewOraclizeQuery("Asking for a new ticket...");
//         bytes32 userTicketID = oraclize_query("WolframAlpha", _setTicketQuery(_ticketOwner),oraclizeGasLimit);
//         newTicketID[userTicketID] = _ticketOwner;
//     }

//     /** @dev _setTicketQuery is a function which sets the query to ask for a ticket to WolframAlpha through oraclize.
//       * @param _parametersOwner is the address of the user which is going to receive the ticket, e.g. a user asking for a ticket or the admin of the contract when calling for a
//       * Lucky7Number. The final shape of the query is (mod((1/(10^n-mu))*10^p,10^(j+i))-mod((1/(10^n-mu))*10^p,10^(i)))/10^i, and this function uses the strConcat function of
//       * the usingOraclize contract to concat the parts with the parameters of the user.
//       * Every line explains how the query is getting it shape. The meaning of this query is going to be explained on the paper of the project.
//       */
//     function _setTicketQuery(address _parametersOwner) internal returns (string){
//         string memory queryWolfram;
//         //This line => (mod((1/(10^n-mu))*10^    
//         queryWolfram = strConcat("(mod((1/(10^",n,"-",userValues[_parametersOwner].mu,"))*10^");
//         //This line => (mod((1/(10^n-mu))*10^p,10^(j+
//         queryWolfram = strConcat(queryWolfram,p,",10^(",j,"+");
//         //This line => (mod((1/(10^n-mu))*10^p,10^(j+i))-mod((1/(10^n-
//         queryWolfram = strConcat(queryWolfram,userValues[_parametersOwner].i,"))-mod((1/(10^",n,"-");
//         //This line => (mod((1/(10^n-mu))*10^p,10^(j+i))-mod((1/(10^n-mu))*10^p,10^
//         queryWolfram = strConcat(queryWolfram,userValues[_parametersOwner].mu,"))*10^",p,",10^");
//         //This line => (mod((1/(10^n-mu))*10^p,10^(j+i))-mod((1/(10^n-mu))*10^p,10^(i)))/10^i
//         queryWolfram = strConcat(queryWolfram,"(",userValues[_parametersOwner].i,")))/10^",userValues[_parametersOwner].i);
//         emit NewWolframQuery(queryWolfram);
//         return queryWolfram;
//     }

//     /** @dev _generateTicket is used for another contract. Invokes _askForMuParameter and _askForIparameter
//       */
//     function _generateTicket(address _ticketOwner) public {
//         _askForMuParameter(_ticketOwner);
//         _askForIParameter(_ticketOwner);
//     }
    
//     /** @dev _insertTicket inserts a ticket in the ticketsArray array.
//       * @param _ticketOwner is the owner of the ticket already generated. It uses the UserParametersValue struct values and the drawNumber value.
//       * Then it call the _checkForLucky7Ticket function to check if the inserted ticket is a Lucky7Ticket.
//       * Because a push return the size of the array, is necessary to decrement the id value in 1 to check the current ticket. 
//       */
//     function _insertTicket(address _ticketOwner) internal {
//         uint id = ticketsArray.push(Ticket(userValues[_ticketOwner].mu,userValues[_ticketOwner].i,userValues[_ticketOwner].ticketValue,_ticketOwner,drawNumber)) - 1;
//         _checkForLucky7Ticket(id);
//     }

//     /** @dev _insertLucky7Number inserts a Lucky7Number in the lucky7NumbersArray array.
//       * @param _ticketOwner is the owner, but in this case is the owner of the contract. This is setted this way to take advantage of the UserParametersValue struct
//       * and store it the same way the tickets are stored. Once stored, the indexForLucky7Array is incremented by 1, so next time this function is called, the next
//       * Lucky7Number don't replace the last inserted. 
//       * Then an event is emited.
//       */
//     function _insertLucky7Number(address _ticketOwner) internal {
//         lucky7NumbersArray[indexForLucky7Array] = Lucky7Number(userValues[_ticketOwner].mu,userValues[_ticketOwner].i,userValues[_ticketOwner].ticketValue,drawNumber);
//         indexForLucky7Array++;
//         emit NewLucky7Number(userValues[_ticketOwner].ticketValue);
//     }
    
//     /** @dev _checkForLucky7Ticket is a function that check if a ticket recently inserted in the ticketsArray is a Lucky7Ticket.
//       * @param _ticketID is the ticket which is going to be checked.
//       * At this point, the Lucky7Numbers are ordered by them values in ascedant order.
//       * This function uses the SafeMath library to avoid integer underflow or overflow, or to check that the difference is not 0, which is a special case.
//       */
//     function _checkForLucky7Ticket(uint _ticketID) public{
//         uint i;
//         uint difference;
//         /** @dev First it checks if the ticket is bigger than the last Lucky7Number.
//           * If so, sets the auxiliary parameter i to the id of the last Lucky7Number, numberOfLucky7Numbers-1 in this case. Don't confuse with the i parameter of the PRNG.
//           * Then the difference between them is obtained through the sub function of the SafeMath library, knowing that the ticket is bigger than the last Lucky7Number.
//           */
//         if(ticketsArray[_ticketID].ticketValue>lucky7NumbersArray[numberOfLucky7Numbers-1].ticketValue){
//             i = numberOfLucky7Numbers-1;
//             difference = ticketsArray[_ticketID].ticketValue.sub(lucky7NumbersArray[i].ticketValue);
            
//         }
//         /** @dev If it is not bigger than the last Lucky7Number, then checks if it is smaller thant the first Lucky7Number.
//           * If so, sets the auxiliary parameter i to the id of the first Lucky7Number, 0 in this case. Don't confuse with the i parameter of the PRNG.
//           * Then the difference between them is obtained through the sub function of the SafeMath library, knowing that the ticket is smaller than the first Lucky7Number.
//           */
//         else if (ticketsArray[_ticketID].ticketValue<lucky7NumbersArray[0].ticketValue){
//             i = 0;
//             difference = lucky7NumbersArray[i].ticketValue.sub(ticketsArray[_ticketID].ticketValue);
//         }

//         /** @dev If none of the above fits, then the ticket could be bigger or equal than the first Lucky7Number or smaller or equal than the last Lucky7Number.
//           * The function proceeds then to look which is it interval,i.e. it should be between two Lucky7Numbers or equal to one Lucky7Number.
//           */
//         else{
//             /** @dev The function then proceed to increment i until the ticket is bigger than the Lucky7Number[i].
//               */
//             while(ticketsArray[_ticketID].ticketValue>lucky7NumbersArray[i].ticketValue){ 
//                 i++;
//             }
//             /** @dev If the ticket and the correspondent Lucky7Numbers are equal, then the ticket is a ExactLucky7Ticket
//               */
//             if(ticketsArray[_ticketID].ticketValue==lucky7NumbersArray[i].ticketValue){
//                 difference = 0;
//             }
//             else{
//                 /** @dev If not, then it will have to check if the Lucky7Number above or below the ticket is closer
//                   * if the below Lucky7Number is closer to the ticket than the above Lucky7Number (if(upperLucky7NumberDifference>lowerLucky7NumberDifference)) then the 
//                   * correspondent candidate to Lucky7Ticket is the Lucky7Number which is below the ticket.
//                   * Else, the above Lucky7Number is the correspondent candidate.
//                   * Then saves the value of difference.
//                   */
//                 uint lowerLucky7NumberDifference = ticketsArray[_ticketID].ticketValue.sub(lucky7NumbersArray[i-1].ticketValue);
//                 uint upperLucky7NumberDifference = lucky7NumbersArray[i].ticketValue.sub(ticketsArray[_ticketID].ticketValue);
                
//                 if(upperLucky7NumberDifference>lowerLucky7NumberDifference){
//                     i=i-1;
//                     difference = lowerLucky7NumberDifference;
//                 }
//                 else{
//                     difference = upperLucky7NumberDifference;
//                 }
//             }
//         }
//         /** @dev Now the function proceed to check if it is in fact a Lucky7Ticket.
//           * If the Lucky7Ticket[i] hasn't an owner, then the ticket is automatically assigned as Lucky7Ticket.
//           * If it has an owner, then check if the difference is smaller than the difference of the current owner.
//           * If it is smaller, then the ticket is a Lucky7Ticket and is stored in the Lucky7Ticket mappings.
//           * Then an event is emitted.
//           */
//         if(lucky7TicketOwner[i] == address(0x0) || difference<lucky7TicketDifference[i]){
//             lucky7TicketOwner[i] = ticketsArray[_ticketID].owner;
//             lucky7TicketDifference[i] = difference;
//             lucky7TicketID[i] = _ticketID;
//             emit NewLucky7Ticket(_ticketID);
//         }
//         /** @dev Then, checks if it's a ExactLucky7Ticket.
//           * Due to the high entropy of the PRNG is pretty unfeasible to get an ExactLucky7Ticket without having the same mu and i parameters than the
//           * Lucky7Number. The probability of having two identical ExactLucky7Tickets in the same game is even lower.
//           * If in determinated unfortunate case an user gets a ExacyLucky7Ticket which is already occupied, then it will not replace the old one.
//           * That's why is necessary to storage all the ExactLucky7Tickets to award them specially, e.g. giving them tokens according to some rules, which would be
//           * specified in future developments.
//           * The next step, then, is to check if it is indeed a ExactLucky7Ticket. If so, then store the information in the ExactLucky7Tickets mappings and increment
//           * indexForExactLucky7Ticket by 1.
//           */
//         if(difference == 0){
//             ExactLucky7TicketOwner[indexForExactLucky7Ticket] = ticketsArray[_ticketID].owner;
//             ExactLucky7TicketValue[indexForExactLucky7Ticket] = ticketsArray[_ticketID].ticketValue;
//             ExactLucky7TicketID[indexForExactLucky7Ticket] = _ticketID;
//             indexForExactLucky7Ticket++;
//         }
//     }

//     function() public payable{}
// } 